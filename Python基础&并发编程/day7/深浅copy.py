# -*- coding:utf-8 -*-
# 1、变量赋值赋值后修改
a = 1
b = a
print(id(a),id(b))    # 8791312028704 8791312028704

a = 2           # 改变a的值
print(a,b)   # 2 1   变量b指向的是变量a所在的内存地址，判断两个变量是否内存地址一致，可以通过id（）进行查询
print(id(a),id(b))  # 8791312028736 8791312028704  变量修改变量的值后，列表的内存地址发生改变



# 2、列表赋值后修改
print('--------列表赋值后的内存地址----------')
name = [1,2,3]
name1 = name
print('赋值后列表的内存地址:',id(name),id(name1))   # 33399752 33399752
print('第一个元素的内存地址:',id(name[0]))
print('第二个元素的内存地址:',id(name[0]))

print('--------修改元素的值后的内存地址----------')
# 修改name中的元素1改为-1
name [0] = -1
print('修改元素后列表的内存地址:',id(name),id(name1))   # 35021384 35021384  列表修改元素值后，列表的内存地址没有改变，
# 是因为列表中每一个元素都有自己的独立的的内存地址，而列表本身也是有内存地址的，当我们修改列表中的元素后，列表本身内存地址是不会发生改变，所以两个列表的中的数据是一样的
print(name,name1)
# 修改元素后元素的内存地址发生改变与没修改的那些元素的内存地址不一样，列表内存地址不发生改变
print('修改后第一个元素的内存地址:',id(name[0]))
print('修改后第二个元素的内存地址:',id(name[1]))

# python中这样的赋值操作，生成的新列表和原有列表的内存地址是一样的，如果要生成不同的内存地址，需要用到copy

# 3、浅copy：规律：对于浅copy来说，第一层创建的是新的内存地址，而从第二层开始，指向的都是同一个内存地址，所以，对于第二层以及更深的层数来说，保持一致性。
# 第一步：copy
l1 = [1,2,3,[4,5]]
l2 = l1.copy()
print(l1,l2)    # [1,2,3,[4,5]] [1,2,3,[4,5]]
print(id(l1),id(l2))
# 第二步：修改列表元素
l1[1] = 100
print(l1,l2)    # [1, 100, 3,[4,5]] [1, 2, 3,[4,5]]
print(id(l1),id(l2))
print(id(l1[1]),id(l1[2]),id(l2[1]))   # 8791312028704 8791312028736 8791312028768   # 不同列表的元素内存地址不一样，相同列表的元素内存地址不一样

# 第三步：修改列表中的列表元素
l1[3][0] = 400
print(l1,l2)                # [1,2,3,[400,5]]  [1,2,3,[400,5]]
print(id(l1),id(l2))        # 列表内存地址不一样，不同列表的元素内存地址一样
print(id(l1[0]),id(l1[1]),id(l2[0]))     # 不同列表的元素内存地址一样，相同列表的元素内存地址一样


# 4、深度copy:规律：对于深copy来说，两个是完全独立的，改变任意一个的任何元素（无论多少层），另一个绝对不改变。
import copy
list1 = [11,12,13,[40,41]]
list2 = copy.deepcopy(list1)
print(list1,list2)
print(id(list1),id(list2))    # 42347592 42561992

list1[3][0] = 400
print(list1,list2)
print(id(list1),id(list2))   # [11, 12, 13, [400, 41]] [11, 12, 13, [40, 41]]


