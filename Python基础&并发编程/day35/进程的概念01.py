# -*- coding:utf-8 -*-
# @Author         : 江湖一笑
# @Time           : 2019/10/31 8:48
# @Software       : Python_study
# @Python_verison : 3.7

# 操作系统背景知识
# 顾名思义，进程即正在执行的一个过程。进程是对正在运行程序的一个抽象。
# 进程的概念起源于操作系统，是操作系统最核心的概念，也是操作系统提供的最古老也是最重要的抽象概念之一。操作系统的其他所有内容都是围绕进程的概念展开的。
# 所以想要真正了解进程，必须事先了解操作系统，点击进入
# PS：即使可以利用的cpu只有一个（早期的计算机确实如此），也能保证支持（伪）并发的能力。将一个单独的cpu变成多个虚拟的cpu
# （多道技术：时间多路复用和空间多路复用 + 硬件上支持隔离），没有进程的抽象，现代计算机将不复存在。

# 必备的理论基础：
# 一 操作系统的作用：
# 1：隐藏丑陋复杂的硬件接口，提供良好的抽象接口
# 2：管理、调度进程，并且将多个进程对硬件的竞争变得有序

# 二 多道技术：
# 1.产生背景：
# 针对单核，实现并发
# ps：现在的主机一般是多核，那么每个核都会利用多道技术
# 有4个cpu，运行于cpu1的某个程序遇到io阻塞，会等到io结束再重新调度，会被调度到4个
# cpu中的任意一个，具体由操作系统调度算法决定。

# 2.空间上的复用：
# 如内存中同时有多道程序

# 3.时间上的复用：
# 复用一个cpu的时间片
# 强调：遇到io切，占用cpu时间过长也切，核心在于切之前将进程的状态保存下来，这样
# 才能保证下次切换回来时，能基于上次切走的位置继续运行


# 进程的相关概念
# 什么是进程：
    # 进程是系统资源分配和调度的基本单元
    # 注意：同一个程序执行两次，就会在操作系统中出现两个进程，所以我们可以同时运行一个软件，分别做不同的事情也不会混乱。

# 进程调度：
    # 进程的调度是由操作系统来调度的，这个调度需要遵循一点的法则，由此就产生了进程的调度算法
    # 先来先服务算法
    # 短作业优先算法
    # 时间片轮转算法
    # 多级反馈算法

# 进程的并行和并发:
    # 并行：并行是指两者同时执行，比如赛跑，两个人都在不停的往前跑；（资源够用，比如三个线程，四核的CPU ）
    # 并发：并发是指资源有限的情况下，两者交替轮流使用资源，比如一段路(单核CPU资源)同时只能过一个人，A走一段后，让给B，B用完继续给A ，交替使用，目的是提高效率。

# 进程的同步和异步:
    # 同步：调度之后还一定要等到结果
    # 异步：只管调度，不管结果

# 进程的阻塞和非阻塞:
#     阻塞和非阻塞这两个概念与程序（线程）等待消息通知(无所谓同步或者异步)时的状态有关。也就是说阻塞与非阻塞主要是程序（线程）等待消息通知时的状态角度来说的
#
#     继续上面的那个例子，不论是排队还是使用号码等待通知，如果在这个等待的过程中，等待者除了等待消息通知之外不能做其它的事情，那么该机制就是阻塞的，
#     表现在程序中,也就是该程序一直阻塞在该函数调用处不能继续往下执行。
#     相反，有的人喜欢在银行办理这些业务的时候一边打打电话发发短信一边等待，这样的状态就是非阻塞的，因为他(等待者)没有阻塞在这个消息通知上，而是一边做自己的事情一边等待。
#
#     注意：同步非阻塞形式实际上是效率低下的，想象一下你一边打着电话一边还需要抬头看到底队伍排到你了没有。如果把打电话和观察排队的位置看成是程序的两个操作的话，
#     这个程序需要在这两种不同的行为之间来回的切换，效率可想而知是低下的；而异步非阻塞形式却没有这样的问题，因为打电话是你(等待者)的事情，
#     而通知你则是柜台(消息触发机制)的事情，程序没有在两种不同的操作中来回切换。

# 进程的状态：（就绪、运行、阻塞）
# 首先是进程的【创建】--‘提交’->【就绪】---进程的调度，时间片到了就【运行】---如果遇到阻塞的事件---【阻塞】---阻塞完成后继续是【就绪】状态
# 或者运行时没有阻塞就完成【退出】
# 阻塞的情况有recv、sleep、input、accept

# 进程的创建：让一个程序运行起来
# 所有的进程都是被进程创建起来的
# 父进程、子进程

# 进程的结束：　　
# 1. 正常退出（自愿，如用户点击交互式页面的叉号，或程序执行完毕调用发起系统调用正常退出，在linux中用exit，在windows中用ExitProcess）
# 2. 出错退出（自愿，python a.py中a.py不存在）
# 3. 严重错误（非自愿，执行非法指令，如引用不存在的内存，1/0等，可以捕捉异常，try...except...）
# 4. 被其他进程杀死（非自愿，如kill -9）